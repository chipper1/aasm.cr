{"name":"Aasm.cr","tagline":"Easy to use finite state machine for Crystal classes.","body":"Aasm stands for **\"Acts As State Machine\"** which means that some abstract object can act as a [finite state machine](https://en.wikipedia.org/wiki/Finite-state_machine) and can be in one of a finite number of states at a time; can change one state to another when initiated by a triggering event.\r\n\r\n# Getting Started\r\n\r\nAdding a state machine to a Crystal class is as simple as including `AASM` module and writing `act_as_state_machine` method where you can define **states** and **events** with their **transitions**:\r\n\r\n```crystal\r\nclass Transaction\r\n  include AASM\r\n\r\n  def act_as_state_machine\r\n    aasm.state :pending, initial: true\r\n    aasm.state :active,  enter: -> { puts \"Just got activated\" }\r\n    aasm.state :completed\r\n\r\n    aasm.event :activate do |e|\r\n      e.transitions from: :pending, to: :active\r\n    end\r\n\r\n    aasm.event :complete do |e|\r\n      e.transitions from: :active, to: :completed\r\n    end\r\n  end\r\nend\r\n\r\nt = Transaction.new.tap &.act_as_state_machine\r\nt.state          #=> :pending\r\nt.next_state     #=> :active\r\nt.fire :activate # Just got activated\r\nt.state          #=> :active\r\nt.next_state     #=> :completed\r\n```\r\n\r\n## States\r\n\r\nState can be defined using `aasm.state` method passing the name and options:\r\n\r\n```crystal\r\naasm.state :passive, initial: true\r\n```\r\n\r\n### State options\r\n\r\nCurrently state supports the following options:\r\n\r\n  - `initial` : `Bool` **optional** - indicates whether this state is initial or not. If initial state not specified, first one will be considered as initial\r\n  - `guard` : `(-> Bool)` **optional** - a callback, that gets evaluated once state is getting entered. State will not enter if guard returns false\r\n  - `enter` : `(->)` **optional** - a hook, that gets evaluated once state entered.\r\n\r\n## Events\r\n\r\nEvent can be defined using `aasm.state` method passing the name and a block with transitions:\r\n\r\n```crystal\r\naasm.event :delete do |e|\r\n  e.transitions from: :active, to: :deleted\r\nend\r\n``` \r\n\r\nEvent has to be defined after state definition. In other case `NoSuchStateException` will be raise.\r\n\r\n## Transitions\r\n\r\nTransition can be defined on event with `transitions` method passing options:\r\n\r\n```crystal\r\naasm.event :complete do |e|\r\n  e.transitions from: [:pending, :active], to: :deleted\r\nend\r\n```\r\n\r\n### Transition options\r\n\r\nCurrently transition supports the following options:\r\n\r\n  - `from` : `(Symbol | Array(Symbol))` **required** - state (or states) from which state of state machine can be changed when event fired\r\n  - `to` : `Symbol` **required** - state to which state of state machine will change when event fired.\r\n\r\n# More examples\r\n\r\n## One state machine (circular)\r\n\r\n```crystal\r\nclass CircularStateMachine\r\n  include AASM\r\n\r\n  def act_as_state_machine\r\n    aasm.state :started\r\n\r\n    aasm.event :restart do |e|\r\n      e.transitions from: :started, to: :started\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n## Two states machine\r\n\r\n```crystal\r\nclass TwoStateMachine\r\n  include AASM\r\n\r\n  def act_as_state_machine\r\n    assm.state :active\r\n    aasm.state :deleted\r\n\r\n    aasm.event :delete do |e|\r\n      e.transitions from: :active, to: :deleted\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n## Three states machine\r\n\r\n```crystal\r\nclass ThreeStatesMachine\r\n  include AASM\r\n\r\n  def act_as_state_machine\r\n    aasm.state :pending, initial: true\r\n    aasm.state :active\r\n    aasm.state :completed\r\n\r\n    aasm.event :activate do |e|\r\n      e.transitions from: :pending, to: :active\r\n    end\r\n    aasm.event :complete do |e|\r\n      e.transitions from: [:active, :pending], to: :completed\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n","google":"UA-63584551-3","note":"Don't delete this file! It's used internally to help with page regeneration."}